# Jeju JNS Gateway - Standalone
# Name resolution and decentralized frontend serving

FROM oven/bun:1.1-alpine AS builder

WORKDIR /app

# Create minimal package.json with only required deps
RUN echo '{"name":"jns-gateway","dependencies":{"elysia":"^1.4.19","@elysiajs/cors":"^1.4.0","viem":"^2.0.0"}}' > package.json

# Install dependencies
RUN bun install

# Create the JNS gateway source inline using heredoc
RUN mkdir -p src && cat > src/jns-gateway.ts << 'ENDOFFILE'
import { cors } from "@elysiajs/cors";
import { Elysia } from "elysia";

const PORT = parseInt(process.env.JNS_GATEWAY_PORT ?? "4005");
const IPFS_GATEWAY = process.env.IPFS_GATEWAY_URL ?? "http://ipfs:8080";

interface CacheEntry { content: string; expiry: number; }
const cache = new Map<string, CacheEntry>();
const CACHE_TTL = 300_000;

function getFromCache(name: string): string | null {
  const entry = cache.get(name);
  if (entry && entry.expiry > Date.now()) return entry.content;
  if (entry) cache.delete(name);
  return null;
}

function setCache(name: string, content: string): void {
  cache.set(name, { content, expiry: Date.now() + CACHE_TTL });
}

const app = new Elysia()
  .use(cors())
  .get("/health", () => ({ status: "healthy", service: "jns-gateway", cacheSize: cache.size }))
  .get("/resolve/:name", async ({ params }) => {
    const name = params.name;
    const cached = getFromCache(name);
    if (cached) return { name, contenthash: cached, cached: true };
    return { name, error: "JNS resolution not configured" };
  })
  .get("/ipfs/:cid/*", async ({ params, path, set }) => {
    const cid = params.cid;
    const pathAfter = path.split("/ipfs/" + cid)[1] || "";
    try {
      const url = IPFS_GATEWAY + "/ipfs/" + cid + pathAfter;
      const response = await fetch(url);
      if (!response.ok) {
        set.status = 404;
        return { error: "Content not found" };
      }
      const contentType = response.headers.get("content-type") || "application/octet-stream";
      const body = await response.arrayBuffer();
      return new Response(body, { headers: { "Content-Type": contentType } });
    } catch {
      set.status = 500;
      return { error: "Failed to fetch from IPFS" };
    }
  })
  .get("/:name/*", async ({ params, path, redirect, set }) => {
    const fullPath = path;
    const nameMatch = fullPath.match(/\/([^\/]+)\.jeju/);
    if (!nameMatch) {
      set.status = 400;
      return { error: "Invalid JNS path" };
    }
    const name = nameMatch[1] + ".jeju";
    const pathAfterName = fullPath.replace(/\/[^\/]+\.jeju/, "");
    const contenthash = getFromCache(name);
    if (!contenthash) {
      set.status = 404;
      return { error: "Name not resolved" };
    }
    return redirect("/ipfs/" + contenthash + pathAfterName);
  })
  .get("/", () => ({
    service: "Jeju JNS Gateway",
    version: "1.0.0",
    endpoints: { health: "/health", resolve: "/resolve/:name", ipfs: "/ipfs/:cid", serve: "/:name.jeju/*" }
  }));

console.log("JNS Gateway listening on port " + PORT);
app.listen(PORT);
ENDOFFILE

# Build
RUN bun build ./src/jns-gateway.ts --outdir=./dist --target=bun --minify

# Runtime stage
FROM oven/bun:1.1-alpine

WORKDIR /app

# Install curl for health checks
RUN apk add --no-cache curl

# Copy built files
COPY --from=builder /app/dist/ ./dist/
COPY --from=builder /app/node_modules/ ./node_modules/
COPY --from=builder /app/package.json ./

USER bun

HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -sf http://localhost:${JNS_GATEWAY_PORT:-4005}/health || exit 1

EXPOSE 4005

CMD ["bun", "run", "dist/jns-gateway.js"]
