/**
 * Malware Scanning Provider
 *
 * DESIGN AXIOM: Automated first, human last
 * Malware detection is fully automated with no human review.
 *
 * Scanning strategies:
 * 1. YARA rules for pattern matching
 * 2. Binary entropy analysis (high entropy = likely packed/encrypted)
 * 3. Known malware hash database
 * 4. External APIs (VirusTotal, ClamAV)
 *
 * For containers/compute:
 * - Static analysis before execution
 * - Runtime behavior monitoring (not in this module)
 */

import { logger } from '../../logger'

export interface MalwareScanResult {
  isMalicious: boolean
  confidence: number
  detectionMethod:
    | 'yara'
    | 'entropy'
    | 'hash'
    | 'virustotal'
    | 'clamav'
    | 'combined'
  threatType?:
    | 'virus'
    | 'trojan'
    | 'ransomware'
    | 'cryptominer'
    | 'backdoor'
    | 'generic'
  threatName?: string
  details?: string
}

export interface MalwareProviderConfig {
  /** Enable YARA scanning (default: true) */
  enableYara?: boolean
  /** Enable entropy analysis (default: true) */
  enableEntropy?: boolean
  /** Enable hash checking (default: true) */
  enableHashCheck?: boolean
  /** Entropy threshold for suspicion (default: 7.5 out of 8) */
  entropyThreshold?: number
  /** VirusTotal API key */
  virusTotalApiKey?: string
  /** ClamAV socket path */
  clamavSocket?: string
}

// Known malware file signatures (first bytes)
const MALWARE_SIGNATURES: Array<{
  pattern: Buffer
  name: string
  type: MalwareScanResult['threatType']
}> = [
  // PE executable with known malware patterns
  {
    pattern: Buffer.from('MZ', 'ascii'),
    name: 'PE_Executable',
    type: 'generic',
  },
  // ELF with suspicious patterns
  {
    pattern: Buffer.from([0x7f, 0x45, 0x4c, 0x46]),
    name: 'ELF_Binary',
    type: 'generic',
  },
]

// Known malware hashes (SHA256)
const KNOWN_MALWARE_HASHES = new Set<string>([
  // Example hashes - would be populated from threat intelligence feeds
  // 'abc123...' // WannaCry
  // 'def456...' // NotPetya
])

// Suspicious file extensions
const SUSPICIOUS_EXTENSIONS = new Set([
  '.exe',
  '.scr',
  '.bat',
  '.cmd',
  '.com',
  '.pif',
  '.vbs',
  '.vbe',
  '.js',
  '.jse',
  '.ws',
  '.wsf',
  '.wsc',
  '.wsh',
  '.ps1',
  '.psm1',
  '.msi',
  '.msp',
  '.hta',
  '.cpl',
  '.jar',
  '.reg',
])

// Suspicious strings to search for in files
const SUSPICIOUS_STRINGS = [
  'powershell',
  'cmd.exe',
  '/bin/sh',
  '/bin/bash',
  'CreateRemoteThread',
  'VirtualAllocEx',
  'WriteProcessMemory',
  'eval(',
  'exec(',
  'system(',
  'shell_exec(',
  'base64_decode',
  'fromCharCode',
  'WScript.Shell',
  'Scripting.FileSystemObject',
  'cryptocurrency',
  'wallet',
  'bitcoin',
  'ethereum', // Cryptominer indicators
  'ransom',
  'decrypt',
  'your files', // Ransomware indicators
]

async function sha256(buffer: Buffer): Promise<string> {
  const hash = await crypto.subtle.digest('SHA-256', new Uint8Array(buffer))
  return Array.from(new Uint8Array(hash))
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('')
}

/**
 * Calculate Shannon entropy of data
 * Returns value between 0 (low entropy) and 8 (high entropy)
 * High entropy (>7.5) often indicates encryption or compression
 */
function calculateEntropy(buffer: Buffer): number {
  const frequencies = new Uint32Array(256)
  for (const byte of buffer) {
    frequencies[byte]++
  }

  let entropy = 0
  const length = buffer.length
  for (const freq of frequencies) {
    if (freq > 0) {
      const p = freq / length
      entropy -= p * Math.log2(p)
    }
  }

  return entropy
}

/**
 * Malware Scanning Provider
 */
export class MalwareProvider {
  private config: Required<
    Pick<
      MalwareProviderConfig,
      'enableYara' | 'enableEntropy' | 'enableHashCheck' | 'entropyThreshold'
    >
  > &
    MalwareProviderConfig
  private initialized = false

  constructor(config: MalwareProviderConfig = {}) {
    this.config = {
      enableYara: config.enableYara ?? true,
      enableEntropy: config.enableEntropy ?? true,
      enableHashCheck: config.enableHashCheck ?? true,
      entropyThreshold: config.entropyThreshold ?? 7.5,
      virusTotalApiKey: config.virusTotalApiKey,
      clamavSocket: config.clamavSocket,
    }
  }

  async initialize(): Promise<void> {
    if (this.initialized) return

    logger.info('[MalwareProvider] Initialized', {
      yara: this.config.enableYara,
      entropy: this.config.enableEntropy,
      hashCheck: this.config.enableHashCheck,
      virusTotal: !!this.config.virusTotalApiKey,
      clamav: !!this.config.clamavSocket,
    })

    this.initialized = true
  }

  /**
   * Scan buffer for malware
   */
  async scan(buffer: Buffer, filename?: string): Promise<MalwareScanResult> {
    const results: MalwareScanResult[] = []

    // 1. Hash check (fastest)
    if (this.config.enableHashCheck) {
      const hashResult = await this.checkHash(buffer)
      if (hashResult.isMalicious) {
        return hashResult
      }
      results.push(hashResult)
    }

    // 2. Signature/YARA check
    if (this.config.enableYara) {
      const yaraResult = await this.checkSignatures(buffer, filename)
      if (yaraResult.isMalicious && yaraResult.confidence > 0.9) {
        return yaraResult
      }
      results.push(yaraResult)
    }

    // 3. Entropy analysis
    if (this.config.enableEntropy) {
      const entropyResult = this.checkEntropy(buffer)
      results.push(entropyResult)
    }

    // 4. String analysis
    const stringResult = this.checkSuspiciousStrings(buffer)
    results.push(stringResult)

    // 5. External APIs (slower, use for suspicious files)
    const isSuspicious = results.some((r) => r.confidence > 0.5)
    if (isSuspicious) {
      if (this.config.virusTotalApiKey) {
        const vtResult = await this.checkVirusTotal(buffer)
        if (vtResult.isMalicious) {
          return vtResult
        }
        results.push(vtResult)
      }
    }

    // Combine results
    return this.combineResults(results)
  }

  /**
   * Check against known malware hashes
   */
  private async checkHash(buffer: Buffer): Promise<MalwareScanResult> {
    const hash = await sha256(buffer)

    if (KNOWN_MALWARE_HASHES.has(hash)) {
      return {
        isMalicious: true,
        confidence: 1.0,
        detectionMethod: 'hash',
        threatType: 'generic',
        threatName: 'Known_Malware_Hash',
        details: `SHA256: ${hash}`,
      }
    }

    return {
      isMalicious: false,
      confidence: 0,
      detectionMethod: 'hash',
    }
  }

  /**
   * Check file signatures and patterns
   */
  private async checkSignatures(
    buffer: Buffer,
    filename?: string,
  ): Promise<MalwareScanResult> {
    // Check file extension
    if (filename) {
      const ext = filename.toLowerCase().slice(filename.lastIndexOf('.'))
      if (SUSPICIOUS_EXTENSIONS.has(ext)) {
        return {
          isMalicious: false, // Not malicious just for extension, but suspicious
          confidence: 0.3,
          detectionMethod: 'yara',
          details: `Suspicious extension: ${ext}`,
        }
      }
    }

    // Check magic bytes
    for (const sig of MALWARE_SIGNATURES) {
      if (buffer.subarray(0, sig.pattern.length).equals(sig.pattern)) {
        // For executables, check for additional malicious patterns
        const hasPayload = this.hasMaliciousPayload(buffer)
        if (hasPayload) {
          return {
            isMalicious: true,
            confidence: 0.8,
            detectionMethod: 'yara',
            threatType: sig.type,
            threatName: sig.name,
            details: 'Executable with malicious payload patterns',
          }
        }

        return {
          isMalicious: false,
          confidence: 0.2,
          detectionMethod: 'yara',
          details: `Binary type: ${sig.name}`,
        }
      }
    }

    return {
      isMalicious: false,
      confidence: 0,
      detectionMethod: 'yara',
    }
  }

  /**
   * Check for malicious payload patterns in binary
   */
  private hasMaliciousPayload(buffer: Buffer): boolean {
    const text = buffer.toString('latin1').toLowerCase()

    // Check for suspicious API imports
    const maliciousApis = [
      'createremotethread',
      'virtualallocex',
      'writeprocessmemory',
      'loadlibrary',
      'getprocaddress',
      'shellexecute',
    ]

    return maliciousApis.some((api) => text.includes(api))
  }

  /**
   * Analyze entropy (high entropy = likely packed/encrypted)
   */
  private checkEntropy(buffer: Buffer): MalwareScanResult {
    const entropy = calculateEntropy(buffer)

    if (entropy > this.config.entropyThreshold) {
      return {
        isMalicious: false, // High entropy alone doesn't mean malicious
        confidence: 0.4,
        detectionMethod: 'entropy',
        details: `High entropy: ${entropy.toFixed(2)}/8 (may be packed/encrypted)`,
      }
    }

    return {
      isMalicious: false,
      confidence: 0,
      detectionMethod: 'entropy',
      details: `Entropy: ${entropy.toFixed(2)}/8`,
    }
  }

  /**
   * Search for suspicious strings
   */
  private checkSuspiciousStrings(buffer: Buffer): MalwareScanResult {
    const text = buffer.toString(
      'utf-8',
      0,
      Math.min(buffer.length, 1024 * 1024),
    ) // First 1MB
    const textLower = text.toLowerCase()

    const matches: string[] = []
    for (const suspicious of SUSPICIOUS_STRINGS) {
      if (textLower.includes(suspicious.toLowerCase())) {
        matches.push(suspicious)
      }
    }

    if (matches.length >= 5) {
      // Many suspicious strings = likely malicious
      return {
        isMalicious: true,
        confidence: 0.7,
        detectionMethod: 'yara',
        threatType: 'generic',
        threatName: 'Suspicious_Content',
        details: `Found ${matches.length} suspicious strings`,
      }
    } else if (matches.length >= 2) {
      return {
        isMalicious: false,
        confidence: 0.3,
        detectionMethod: 'yara',
        details: `Found suspicious strings: ${matches.join(', ')}`,
      }
    }

    return {
      isMalicious: false,
      confidence: 0,
      detectionMethod: 'yara',
    }
  }

  /**
   * Check VirusTotal API
   */
  private async checkVirusTotal(buffer: Buffer): Promise<MalwareScanResult> {
    if (!this.config.virusTotalApiKey) {
      return {
        isMalicious: false,
        confidence: 0,
        detectionMethod: 'virustotal',
      }
    }

    try {
      const hash = await sha256(buffer)

      // First, check if file is already known
      const checkResponse = await fetch(
        `https://www.virustotal.com/api/v3/files/${hash}`,
        {
          headers: { 'x-apikey': this.config.virusTotalApiKey },
        },
      )

      if (checkResponse.ok) {
        const data = (await checkResponse.json()) as {
          data: {
            attributes: {
              last_analysis_stats: {
                malicious: number
                suspicious: number
                harmless: number
                undetected: number
              }
              popular_threat_classification?: {
                suggested_threat_label?: string
              }
            }
          }
        }

        const stats = data.data.attributes.last_analysis_stats
        const total =
          stats.malicious + stats.suspicious + stats.harmless + stats.undetected
        const detectionRate = (stats.malicious + stats.suspicious) / total

        if (detectionRate > 0.3) {
          return {
            isMalicious: true,
            confidence: Math.min(detectionRate * 2, 1.0),
            detectionMethod: 'virustotal',
            threatType: 'generic',
            threatName:
              data.data.attributes.popular_threat_classification
                ?.suggested_threat_label ?? 'Unknown',
            details: `${stats.malicious}/${total} engines detected malware`,
          }
        }

        return {
          isMalicious: false,
          confidence: 0,
          detectionMethod: 'virustotal',
          details: `${stats.malicious}/${total} engines detected malware`,
        }
      }

      // File not in VT database
      return {
        isMalicious: false,
        confidence: 0,
        detectionMethod: 'virustotal',
      }
    } catch (error) {
      logger.error('[MalwareProvider] VirusTotal check failed', {
        error: String(error),
      })
      return {
        isMalicious: false,
        confidence: 0,
        detectionMethod: 'virustotal',
      }
    }
  }

  /**
   * Combine multiple scan results
   */
  private combineResults(results: MalwareScanResult[]): MalwareScanResult {
    // If any result is definitively malicious, return that
    const malicious = results.find((r) => r.isMalicious && r.confidence >= 0.8)
    if (malicious) {
      return malicious
    }

    // Calculate combined confidence
    let maxConfidence = 0
    let combinedSuspicious = 0

    for (const result of results) {
      if (result.isMalicious) {
        maxConfidence = Math.max(maxConfidence, result.confidence)
      }
      combinedSuspicious += result.confidence
    }

    // If multiple suspicious indicators, escalate
    if (combinedSuspicious > 1.0) {
      return {
        isMalicious: true,
        confidence: Math.min(combinedSuspicious / 2, 0.9),
        detectionMethod: 'combined',
        threatType: 'generic',
        threatName: 'Multiple_Suspicious_Indicators',
        details: `Combined suspicion score: ${combinedSuspicious.toFixed(2)}`,
      }
    }

    return {
      isMalicious: false,
      confidence: maxConfidence,
      detectionMethod: 'combined',
      details: results
        .filter((r) => r.details)
        .map((r) => r.details)
        .join('; '),
    }
  }

  /**
   * Add known malware hash
   */
  addKnownHash(hash: string): void {
    KNOWN_MALWARE_HASHES.add(hash.toLowerCase())
    logger.info('[MalwareProvider] Added known malware hash', {
      hash: hash.slice(0, 16),
    })
  }

  /**
   * Get statistics
   */
  getStats(): {
    knownHashes: number
    signatures: number
    virusTotalEnabled: boolean
    clamavEnabled: boolean
  } {
    return {
      knownHashes: KNOWN_MALWARE_HASHES.size,
      signatures: MALWARE_SIGNATURES.length,
      virusTotalEnabled: !!this.config.virusTotalApiKey,
      clamavEnabled: !!this.config.clamavSocket,
    }
  }
}

// Singleton
let instance: MalwareProvider | null = null

export function getMalwareProvider(
  config?: MalwareProviderConfig,
): MalwareProvider {
  if (!instance) {
    instance = new MalwareProvider(
      config ?? {
        virusTotalApiKey: process.env.VIRUSTOTAL_API_KEY,
      },
    )
  }
  return instance
}

export function resetMalwareProvider(): void {
  instance = null
}
