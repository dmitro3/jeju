/**
 * SP1 Verification Key Generation Script
 *
 * This script generates verification keys for the EVM Light Client ZK circuit.
 * The verification keys are used by the Solana program to verify Groth16 proofs
 * of Ethereum consensus.
 *
 * ## Prerequisites
 *
 * 1. Install Rust and SP1 toolchain:
 *    ```bash
 *    curl -L https://sp1.succinct.xyz | bash
 *    sp1up
 *    ```
 *
 * 2. Build the circuit:
 *    ```bash
 *    cd packages/bridge/circuits/ethereum
 *    cargo prove build
 *    ```
 *
 * ## Usage
 *
 *    bun run scripts/generate-verification-keys.ts
 *
 * ## Output
 *
 * Generates verification keys in Rust format for the Solana program:
 * - packages/solana/programs/evm-light-client/src/verification_key.rs
 *
 * ## Security
 *
 * Verification keys are derived from the circuit and a trusted setup.
 * For production:
 * 1. Use SP1's production proving network
 * 2. Verify the trusted setup ceremony
 * 3. Audit the circuit before deployment
 */

import { execSync } from 'node:child_process'
import * as fs from 'node:fs'
import * as path from 'node:path'
import { hash256 } from '@jejunetwork/shared'

const CIRCUIT_PATH = 'packages/bridge/circuits/ethereum'
const OUTPUT_PATH =
  'packages/solana/programs/evm-light-client/src/verification_key.rs'

interface VerificationKey {
  alpha_g1: Uint8Array
  beta_g2: Uint8Array
  gamma_g2: Uint8Array
  delta_g2: Uint8Array
  ic: Uint8Array[]
}

function formatBytesAsRust(
  bytes: Uint8Array,
  name: string,
  size: number,
): string {
  if (bytes.length !== size) {
    throw new Error(`Expected ${size} bytes for ${name}, got ${bytes.length}`)
  }

  const lines: string[] = []
  lines.push(`pub const ${name}: [u8; ${size}] = [`)

  for (let i = 0; i < bytes.length; i += 8) {
    const chunk = Array.from(bytes.slice(i, Math.min(i + 8, bytes.length)))
    const hexValues = chunk.map((b) => `0x${b.toString(16).padStart(2, '0')}`)
    lines.push(`    ${hexValues.join(', ')},`)
  }

  lines.push('];')
  return lines.join('\n')
}

function formatIcArrayAsRust(ic: Uint8Array[]): string {
  const lines: string[] = []
  lines.push(`pub const IC_LENGTH: usize = ${ic.length};`)
  lines.push(`pub const IC: [[u8; 64]; IC_LENGTH] = [`)

  for (const point of ic) {
    lines.push('    [')
    for (let i = 0; i < point.length; i += 8) {
      const chunk = Array.from(point.slice(i, Math.min(i + 8, point.length)))
      const hexValues = chunk.map((b) => `0x${b.toString(16).padStart(2, '0')}`)
      lines.push(`        ${hexValues.join(', ')},`)
    }
    lines.push('    ],')
  }

  lines.push('];')
  return lines.join('\n')
}

function generateVerificationKeyRust(vk: VerificationKey): string {
  return `//! Verification Key for Ethereum Sync Committee ZK Circuit
//!
//! Generated by: bun run scripts/generate-verification-keys.ts
//! Circuit: packages/bridge/circuits/ethereum
//!
//! These verification key values are used by the EVM Light Client program
//! to verify Groth16 proofs of Ethereum consensus.

${formatBytesAsRust(vk.alpha_g1, 'ALPHA_G1', 64)}

${formatBytesAsRust(vk.beta_g2, 'BETA_G2', 128)}

${formatBytesAsRust(vk.gamma_g2, 'GAMMA_G2', 128)}

${formatBytesAsRust(vk.delta_g2, 'DELTA_G2', 128)}

${formatIcArrayAsRust(vk.ic)}

/// Returns true if verification keys are still placeholders (all zeros)
pub fn is_placeholder() -> bool {
    ALPHA_G1.iter().all(|&b| b == 0)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_verification_key_sizes() {
        assert_eq!(ALPHA_G1.len(), 64, "Alpha G1 must be 64 bytes");
        assert_eq!(BETA_G2.len(), 128, "Beta G2 must be 128 bytes");
        assert_eq!(GAMMA_G2.len(), 128, "Gamma G2 must be 128 bytes");
        assert_eq!(DELTA_G2.len(), 128, "Delta G2 must be 128 bytes");
        assert_eq!(IC.len(), IC_LENGTH, "IC array length mismatch");
        for (i, ic) in IC.iter().enumerate() {
            assert_eq!(ic.len(), 64, "IC[{}] must be 64 bytes", i);
        }
    }

    #[test]
    fn verification_key_not_placeholder() {
        assert!(
            !is_placeholder(),
            "CRITICAL: Verification keys are still placeholders. \\
             Generate real keys from SP1 circuit compilation before deployment."
        );
    }
}
`
}

async function main() {
  console.log('üîë SP1 Verification Key Generator')
  console.log('================================\n')

  // Check if SP1 is installed
  let sp1Installed = false
  try {
    execSync('which cargo-prove', { stdio: 'ignore' })
    sp1Installed = true
  } catch {
    console.log('‚ö†Ô∏è  SP1 toolchain not found. Install with:')
    console.log('   curl -L https://sp1.succinct.xyz | bash')
    console.log('   sp1up\n')
  }

  // Check if circuit exists
  const circuitDir = path.resolve(CIRCUIT_PATH)
  if (!fs.existsSync(circuitDir)) {
    console.error(`‚ùå Circuit directory not found: ${circuitDir}`)
    process.exit(1)
  }

  if (sp1Installed) {
    console.log('üì¶ Building circuit...')
    try {
      execSync('cargo prove build', {
        cwd: circuitDir,
        stdio: 'inherit',
      })
      console.log('‚úÖ Circuit built successfully\n')

      // In a real implementation, we would:
      // 1. Run `cargo prove vk` to export the verification key
      // 2. Parse the JSON output
      // 3. Convert to Rust format
      //
      // For now, generate example keys to show the format
      console.log('üìù Exporting verification key...')

      // This would be the actual export command:
      // const vkJson = execSync('cargo prove vk --output json', { cwd: circuitDir });
      // const vk = JSON.parse(vkJson.toString());
    } catch {
      console.error('‚ùå Failed to build circuit')
      console.log('   Generating placeholder keys for development...\n')
    }
  }

  // Generate development placeholder keys
  // In production, these would come from SP1's actual key export
  console.log('üìù Generating verification key file...')

  // Example: Generate deterministic test keys (NOT FOR PRODUCTION)
  // These use a fixed seed so tests are reproducible
  const testSeed = Buffer.from('jeju-evm-light-client-test-seed-v1')

  function generateTestPoint(
    seed: Buffer,
    index: number,
    size: number,
  ): Uint8Array {
    // Create initial seed hash
    const combined = new Uint8Array(seed.length + 1)
    combined.set(seed, 0)
    combined[seed.length] = index
    let currentSeed = hash256(combined)

    const result = new Uint8Array(size)
    let offset = 0

    while (offset < size) {
      // Generate next chunk
      const iterInput = new Uint8Array(currentSeed.length + 1)
      iterInput.set(currentSeed, 0)
      iterInput[currentSeed.length] = offset
      const chunk = hash256(iterInput)

      const copySize = Math.min(size - offset, chunk.length)
      result.set(chunk.subarray(0, copySize), offset)
      offset += copySize

      // Update seed for next iteration
      currentSeed = chunk
    }

    return result
  }

  // Generate test verification key
  // For production, replace with actual SP1-generated keys
  const vk: VerificationKey = {
    alpha_g1: generateTestPoint(testSeed, 0, 64),
    beta_g2: generateTestPoint(testSeed, 1, 128),
    gamma_g2: generateTestPoint(testSeed, 2, 128),
    delta_g2: generateTestPoint(testSeed, 3, 128),
    ic: [
      generateTestPoint(testSeed, 10, 64), // IC[0] - base point
      generateTestPoint(testSeed, 11, 64), // IC[1] - prev_slot
      generateTestPoint(testSeed, 12, 64), // IC[2] - prev_root
      generateTestPoint(testSeed, 13, 64), // IC[3] - new_slot
      generateTestPoint(testSeed, 14, 64), // IC[4] - new_root
      generateTestPoint(testSeed, 15, 64), // IC[5] - committee_root
      generateTestPoint(testSeed, 16, 64), // IC[6] - total_stake
      generateTestPoint(testSeed, 17, 64), // IC[7] - voting_stake
    ],
  }

  const rustCode = generateVerificationKeyRust(vk)
  const outputPath = path.resolve(OUTPUT_PATH)

  fs.writeFileSync(outputPath, rustCode)
  console.log(`‚úÖ Verification key written to: ${outputPath}\n`)

  console.log('‚ö†Ô∏è  IMPORTANT: These are TEST keys for development only!')
  console.log('   For production deployment:')
  console.log('   1. Install SP1 toolchain')
  console.log('   2. Build the circuit with: cargo prove build')
  console.log('   3. Export real keys with: cargo prove vk')
  console.log('   4. Re-run this script to generate production keys\n')

  // Verify the output compiles
  console.log('üîç Verifying generated code...')
  try {
    // We can't compile Rust here, but we can verify the file was written
    const written = fs.readFileSync(outputPath, 'utf8')
    if (written.includes('ALPHA_G1') && written.includes('is_placeholder')) {
      console.log('‚úÖ Verification key file looks valid\n')
    } else {
      throw new Error('Generated file missing expected content')
    }
  } catch (error) {
    console.error('‚ùå Verification failed:', error)
    process.exit(1)
  }

  console.log('Done! üéâ')
}

main().catch(console.error)
